#7. SZÁL- ÉS HÁLÓZAT KEZELÉS

###Az előző ismétlése:
- Tisztában vagyunk a navigációval
- Az Application Lifecycle is a barátunk már
- Előkészítettünk némi adat a szervereken

Hát kezdjünk is vele valamit!

###Mi következik most?
- Egy kicsit kiegészítjük a Swift tudásunk, némi memória kezelés, megismerjük mi az ARC és mire jó, illetve a wek kulcsszó is fontos lesz
- Utána egy kis szálkezelés is szóba kerül, ugye hosszabb műveleteket nem végzünk a fő szálon
- Az egyszerűbb utat választjuk, Operationök és OperationQueue-kat használunk
- Letöltjük a képernyőhöz szükséges adatokat NSURLSession illetve az AlamoFire használatával
- Parsoljuk az adatokat a modelleknek megfelelően

###Memória kezelés:

- [Alap olvasmány](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html)
- Ezek is jók [link 1](http://www.aidanf.net/learn-swift/memory_management), [link 2](https://hacking-ios.cocoagarage.com/memory-management-in-swift-principles-prevention-and-cures-31116ae0834f#.hzefh8rr1)
- [Végül egy advancedebb írás](https://www.ibm.com/developerworks/library/mo-ios-memory/)
- [Cikkek mellett legyen egy videó is](https://realm.io/news/hector-matos-memory-management/)


###ARC: Strong és weak referenciák

Az ARC rendezkedik a háttrében:

```objective-c
- (void)releaseTheKraken {
    Kraken *kraken = [[Kraken alloc] init]; //+1 retain
    [kraken release]; //now generated by ARC
}
```

Egész jól csinálja, de egy baj marad, circular reference, [ez a kép](https://realm.io/assets/img/news/Hector-Matos-Human-Heart-strong-strong.jpg) jól mutatja a problémát.


Példa, amikor egy objektum erősen fogja a másikat

```swift
//Kraken holds a strong reference to the yummy human.
class Kraken {
    var yummyHuman: Human
}
```

A clusureokra is figyelni kell:

```swift
// The animation closure holds a strong reference to self
// self.retainCount is 1 here
UIView.animateWithDuration(0.3) {
    // self.retainCount is 2 here
    self.view.alpha = 0.0
}
```

Amíg a ref count magasabb mint 0, nem engedhető el a memória.

Hogy lehet mégis? A weak segít:

```swift
class KrakensFace: UIView {
  @IBOutlet weak var razorSharpTeeth: UIView!
}

KrakenAPI.eat(yummyHuman, whenFinished: { [weak self] in
  self?.waitForNextMealTime()
})
```


###Szálak és kezelésük

Ez már fogósabb téma, de igyekszem a könnyebb végét megközelíteni.

Abból indulunk ki, ha a UI szálon végzünk valami nagyobb műveletet szinkron módon, akkor addig blokkoljuk azt.

Néhány hasznos olvasmány:
- [](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)
- [](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html)

Megnyugtatok mindenkit, nem fogunk most sima threadekkel dolgozni, arra ennyi idő nem is lenne elég. Sőt az alacsony szintű GCD se kerül most elő közvetlenül, van egyszerűbb, de egyúttal megbízható és biztonságos megoldás.

Még olvasmány:
- [](http://www.appcoda.com/ios-concurrency/)


A GCD-ből, amire szükségünk van az a queue fogalma. FIFO adastruktúra, mint a mozipénztár, gyűlnek az emberek sorba, egy pénztáros mindig csak egy emberrel foglalkozik, mindig a következővel. Aki előbb áll be, előbb megy ki.

Lásd [ábra](http://www.appcoda.com/wp-content/uploads/2015/10/queue-line-2-1166050-1280x960.jpg).


Persze lehet több pénztár is, az már a concurrent queue. És persze a prioritásokkal is lehet játszani.

TODO: kell ábra

Nos a GCD erre egy alacsony szintű C API-t ad, és itt jön a képbe az NSOperation és az NSOperationQueue.

Előbbi egy absztrakt osztály, két megvalósítása van:
- NSBlockOperation
- NSInvociationOperation

Mindkettő esetében lehet állítani:
- függősések
- prioritások
- és cancelezhetőek.

Egy kis kód jöhet ide:

```swift
@IBAction func didClickOnStart(sender: AnyObject) {
    queue = NSOperationQueue()
    let operation1 = NSBlockOperation(block: {
        let img1 = Downloader.downloadImageWithURL(imageURLs[0])
        NSOperationQueue.mainQueue().addOperationWithBlock({
            self.imageView1.image = img1
        })
    })

    operation1.completionBlock = {
        print("Operation 1 completed")
    }
    queue.addOperation(operation1)

    let operation2 = NSBlockOperation(block: {
        let img2 = Downloader.downloadImageWithURL(imageURLs[1])
        NSOperationQueue.mainQueue().addOperationWithBlock({
            self.imageView2.image = img2
        })
    })

    operation2.completionBlock = {
        print("Operation 2 completed")
    }
    queue.addOperation(operation2)


    let operation3 = NSBlockOperation(block: {
        let img3 = Downloader.downloadImageWithURL(imageURLs[2])
        NSOperationQueue.mainQueue().addOperationWithBlock({
            self.imageView3.image = img3
        })
    })

    operation3.completionBlock = {
        print("Operation 3 completed")
    }
    queue.addOperation(operation3)

    let operation4 = NSBlockOperation(block: {
        let img4 = Downloader.downloadImageWithURL(imageURLs[3])
        NSOperationQueue.mainQueue().addOperationWithBlock({
            self.imageView4.image = img4
        })
    })

    operation4.completionBlock = {
        print("Operation 4 completed")
    }
    queue.addOperation(operation4)
}
```

Cancel példa

```swift
@IBAction func didClickOnCancel(sender: AnyObject) {
    self.queue.cancelAllOperations()
}
```

Függőség példa

```swift
operation2.addDependency(operation1)
operation3.addDependency(operation2)
```

Oké, most már rendelkezésre áll az eszköztárunk az internetes hívásokhoz. Az Apple erre kiváló beépített eszközt ad, az NSURLSessiont.

Jó kis bevezető cikk:
https://www.raywenderlich.com/110458/nsurlsession-tutorial-getting-started


Így néz ki az alap ábra:
http://www.raywenderlich.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-20-at-12.27.21-am.png

Példa kód jöhet, példányosítunk

```swift
let defaultSession = NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())

var dataTask: NSURLSessionDataTask?
```

Majd töltsünk is le egy tracklistát iTunesból

```swift
// With NSURLSession
public func fetchAllRooms(completion: ([RemoteRoom]?) -> Void) {
  let url = NSURL(string: "http://localhost:5984/rooms/_all_docs?include_docs=true")!

  let urlRequest = NSMutableURLRequest(
    URL: url,
    cachePolicy: .ReloadIgnoringLocalAndRemoteCacheData,
    timeoutInterval: 10.0 * 1000)
  urlRequest.HTTPMethod = "GET"
  urlRequest.addValue("application/json", forHTTPHeaderField: "Accept")

  let task = urlSession.dataTaskWithRequest(urlRequest)
    { (data, response, error) -> Void in
    guard error == nil else {
      print("Error while fetching remote rooms: \(error)")
      completion(nil)
      return
    }

    guard let json = try? NSJSONSerialization.JSONObjectWithData(data!,
      options: []) as? [String: AnyObject] else {
        print("Nil data received from fetchAllRooms service")
        completion(nil)
        return
    }

    guard let rows = json["rows"] as? [[String: AnyObject]] {
      print("Malformed data received from fetchAllRooms service")
      completion(nil)
      return
    }

    var rooms = [RemoteRoom]()
    for roomDict in rows {
      rooms.append(RemoteRoom(jsonData: roomDict))
    }

    completion(rooms)
  }

  task.resume()
}
```

Ennyi az egész, de mielőtt rámennénk a saját appra, nézzük mit tud az Alamofire.

Ez jó kiindulás:
https://www.raywenderlich.com/121540/alamofire-tutorial-getting-started

Így néz ki az előző AlamoFire használatával

```swift
func fetchAllRooms(completion: ([RemoteRoom]?) -> Void) {
  Alamofire.request(
    .GET,
    "http://localhost:5984/rooms/_all_docs",
    parameters: ["include_docs": "true"],
    encoding: .URL)
    .validate()
    .responseJSON { (response) -> Void in
      guard response.result.isSuccess else {
        print("Error while fetching remote rooms: \(response.result.error)")
        completion(nil)
        return
      }

      guard let value = response.result.value as? [String: AnyObject],
        rows = value["rows"] as? [[String: AnyObject]] else {
          print("Malformed data received from fetchAllRooms service")
           completion(nil)
           return
      }

      var rooms = [RemoteRoom]()
      for roomDict in rows {
        rooms.append(RemoteRoom(jsonData: roomDict))
      }

      completion(rooms)
  }
}
```

Kicsit szebb és áttekinthetőbb így.

Egy dolgot emelnék ki külön, JSON parsolás, szerencsére nem bonyolult

```swift
guard let json = try? NSJSONSerialization.JSONObjectWithData(data!,
      options: []) as? [String: AnyObject] else {
    print("Nil data received from fetchAllRooms service")
    completion(nil)
    return
}
```